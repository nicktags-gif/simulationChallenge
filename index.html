<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>

<meta charset="utf-8" />
<meta name="generator" content="quarto-1.8.21" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />


<title>Simulation Challenge</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>

<!-- htmldependencies:E3FAD763 -->


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Simulation Challenge</h1>
<p class="subtitle lead">Generative Models and Monte Carlo Simulation</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="simulation-challenge---monte-carlo-analysis" class="level1">
<h1>üé≤ Simulation Challenge - Monte Carlo Analysis</h1>
<section id="challenge-overview" class="level2">
<h2>Challenge Overview</h2>
<p><strong>Your Mission:</strong> Create a comprehensive Quarto document that simulates one or two investment strategies, analyzes the results, and demonstrates your ability to present counter-intuitive findings compellingly. Then render the document to HTML and deploy it via GitHub Pages from a new repository called ‚ÄúsimulationChallenge.‚Äù</p>
</section>
<section id="investment-strategy-setup" class="level2">
<h2>Investment Strategy Setup</h2>
<section id="strategy-1-single-coin-flip-investment" class="level3">
<h3>Strategy 1: Single Coin Flip Investment</h3>
<div id="setup-imports" class="cell" data-execution_count="1">
<div class="cell-output cell-output-stdout">
<pre><code>Libraries imported successfully!</code></pre>
</div>
</div>
<div id="strategy-1-single-flip" class="cell" data-execution_count="2">
<div class="cell-output cell-output-stdout">
<pre><code>Sample results (first 10 simulations): [600.0, 1500.0, 1500.0, 1500.0, 600.0, 600.0, 600.0, 1500.0, 1500.0, 1500.0]
Average final balance: $1140.00</code></pre>
</div>
</div>
<div id="strategy-2-multiple-flips" class="cell" data-execution_count="3">
<div class="cell-output cell-output-stdout">
<pre><code>Sample results (5 flips, first 10 simulations): [1215.0, 486.0, 486.0, 1215.0, 194.39999999999998, 77.75999999999999, 3037.5, 3037.5, 1215.0, 1215.0]
Average final balance: $1217.92</code></pre>
</div>
</div>
<div id="analysis-functions" class="cell" data-execution_count="4">
<div class="cell-output cell-output-stdout">
<pre><code>
=== Single Flip Test Analysis ===
Total Simulations: 10
Mean Final Balance: $1140.00
Median Final Balance: $1500.00
Standard Deviation: $440.91
Min Final Balance: $600.00
Max Final Balance: $1500.00
Win Rate (% above $1000): 60.0%</code></pre>
</div>
</div>
<div id="visualization-setup" class="cell" data-execution_count="5">
<div class="cell-output cell-output-stdout">
<pre><code>Visualization functions defined successfully!</code></pre>
</div>
</div>
</section>
</section>
<section id="analysis-questions" class="level2">
<h2>Analysis Questions</h2>
<section id="expected-value-calculation" class="level3">
<h3>1. Expected Value Calculation</h3>
<p><strong>What is the expected value of the final balance for the single coin flip strategy?</strong></p>
<p>For a single coin flip: - Win probability: 50% (0.5) - Win multiplier: 1.5 (+50% gain) - Loss multiplier: 0.6 (-40% loss)</p>
<p><strong>Expected Value = (0.5 √ó 1.5) + (0.5 √ó 0.6) = 0.75 + 0.30 = 1.05</strong></p>
<p>This means the expected final balance is <strong>$1,050</strong> (5% expected gain per flip).</p>
</section>
<section id="expectation-vs-reality" class="level3">
<h3>2. Expectation vs Reality</h3>
<p><strong>Is the expected value positive or negative?</strong></p>
<p>The expected value is <strong>positive</strong> (1.05 &gt; 1.0), meaning we expect to gain money on average. However, this doesn‚Äôt guarantee profit in any single simulation due to the high variance of the strategy.</p>
<p><strong>Key Insight</strong>: While the expected value is positive, the high volatility means individual simulations can vary dramatically from this expectation.</p>
<ol start="3" type="1">
<li>Single Simulation:</li>
</ol>
<div id="single-simulation-dynamics" class="cell" data-execution_count="6">
<div class="cell-output cell-output-stdout">
<pre><code>=== SINGLE SIMULATION RESULTS ===
Initial Balance: $1,000
Final Balance: $114.79
Total Change: $-885.21 (-88.5%)
Wins: 6, Losses: 9
Win Rate: 40.0%
Flip Results: LOSS LOSS LOSS LOSS LOSS LOSS WIN WIN WIN WIN WIN LOSS LOSS WIN LOSS</code></pre>
</div>
</div>
<div id="cell-create-balance-visualization" class="cell" data-execution_count="7">
<div class="cell-output cell-output-stdout">
<pre><code>
=== BALANCE DYNAMICS INSIGHTS ===
Peak Balance: $1,000.00
Lowest Balance: $46.66
Largest Single Gain: $118.10
Largest Single Loss: $-400.00</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img src="index_files/figure-html/create-balance-visualization-output-2.png" id="create-balance-visualization" width="1142" height="949" /></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
=== BALANCE CHANGES SUMMARY ===
Largest Single Gain: $118.10 (+50.0%)
Largest Single Loss: $-400.00 (-40.0%)
Average Change per Flip: $-59.01 (-4.0%)
Total Gains: $371.41
Total Losses: $-1,256.62
Net Change: $-885.21</code></pre>
</div>
</div>
<p>We ended up with a net change of $-885.21. I would not be happy with this result, as we were losing more than we expected. With the 15 flips, we were definitely unlucky with the amount of times we lost, but it showed the law of large numbers at work where if we ran the simulation many times, we would get closer to the expected value.</p>
</section>
</section>
<section id="simulations-analysis" class="level2">
<h2>100 Simulations Analysis</h2>
<p>Now let‚Äôs run 100 simulations to get a better understanding of the distribution of outcomes and create a probability distribution plot of final account balances.</p>
<div id="hundred-simulations" class="cell" data-execution_count="8">
<div class="cell-output cell-output-stdout">
<pre><code>Running 100 simulations...
Completed 100 simulations
Average final balance: $1,806.09
Median final balance: $717.45
Standard deviation: $3,683.99
Min final balance: $7.35
Max final balance: $28,025.21</code></pre>
</div>
</div>
<div id="cell-probability-distribution-analysis" class="cell" data-execution_count="9">
<div class="cell-output cell-output-stderr">
<pre><code>/var/folders/j7/llh6qqjs2pg4w004y7mqkc9m0000gn/T/ipykernel_60117/52686530.py:30: MatplotlibDeprecationWarning:

The &#39;labels&#39; parameter of boxplot() has been renamed &#39;tick_labels&#39; since Matplotlib 3.9; support for the old name will be dropped in 3.11.
</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img src="index_files/figure-html/probability-distribution-analysis-output-2.png" id="probability-distribution-analysis" width="1430" height="949" /></p>
</figure>
</div>
</div>
</div>
<div id="detailed-statistics-analysis" class="cell" data-execution_count="10">
<div class="cell-output cell-output-stdout">
<pre><code>=== DETAILED STATISTICAL ANALYSIS ===
Total Simulations: 100
Mean Final Balance: $1,806.09
Median Final Balance: $717.45
Standard Deviation: $3,683.99
Min Final Balance: $7.35
Max Final Balance: $28,025.21
Win Rate (% above $1000): 34.0%
Average Loss (when losing): $294.05
Average Gain (when winning): $4,741.21
Theoretical Expected Value: $2,078.93
Actual vs Theoretical: 0.869

=== PERCENTILE ANALYSIS ===
5th Percentile: $18.37
10th Percentile: $45.92
25th Percentile: $114.79
50th Percentile: $717.45
75th Percentile: $1,793.61
90th Percentile: $4,484.03
95th Percentile: $11,210.08

=== RISK ASSESSMENT ===
Probability of losing money: 66.0%
Probability of gaining money: 34.0%
Largest loss: $-992.65
Largest gain: $27,025.21</code></pre>
</div>
</div>
<div id="cell-probability-and-standard-deviation-analysis" class="cell" data-execution_count="11">
<div class="cell-output cell-output-stdout">
<pre><code>=== PROBABILITY ANALYSIS ===
Probability of WINNING money: 34.0%
Probability of LOSING money: 66.0%
Probability of BREAKING EVEN: 0.0%

=== STANDARD DEVIATION ANALYSIS ===
Mean Final Balance: $1,806.09
Standard Deviation: $3,683.99
Standard Deviation as % of Mean: 204.0%

One Standard Deviation Above Mean: $5,490.07
One Standard Deviation Below Mean: $-1,877.90

Two Standard Deviations Above Mean: $9,174.06
Two Standard Deviations Below Mean: $-5,561.89

=== DISTRIBUTION WITHIN STANDARD DEVIATIONS ===
Simulations within 1 standard deviation: 94.0%
Simulations within 2 standard deviations: 94.0%

=== GAIN/LOSS PERCENTAGE ANALYSIS ===
Average Loss (when losing): -70.6%
Maximum Loss: -99.3%
Average Gain (when winning): 374.1%
Maximum Gain: 2702.5%</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img src="index_files/figure-html/probability-and-standard-deviation-analysis-output-2.png" id="probability-and-standard-deviation-analysis" width="1334" height="566" /></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
=== KEY INSIGHTS ===
‚Ä¢ The standard deviation is 204.0% of the mean, indicating extremely high volatility
‚Ä¢ Only 0.9% of simulations fall within one standard deviation of the mean
‚Ä¢ The probability of losing money (0.7%) is much higher than winning (0.3%)
‚Ä¢ When you lose, you lose an average of 70.6% of your initial investment
‚Ä¢ When you win, you gain an average of 374.1% of your initial investment</code></pre>
</div>
</div>
<p>This time, after the 100 simulations, we were able to gain a lot of statistical insight about the distribution of outcomes. The results reveal a fascinating paradox: despite having a positive expected value of 5% per flip, most individual simulations actually result in losses. This occurs because the high volatility creates extreme outliers that pull the average up, while the majority of simulations cluster around much lower values. The distribution is heavily right-skewed, showing that this strategy behaves more like a lottery ticket - most people lose, but a few achieve enormous gains. This counterintuitive result perfectly demonstrates why expected value alone is insufficient for evaluating investment strategies, and why understanding the full distribution of possible outcomes is crucial for making informed financial decisions.</p>
<p>Based on our 100 simulations, the probability of ending with an account balance over $1,000 at age 55 is approximately 33%. This low success rate occurs because the strategy‚Äôs high volatility creates a compounding effect where early losses severely reduce the base for future gains. The 40% loss multiplier has a more devastating impact than the 50% gain multiplier, as losing 40% requires a 67% gain just to break even. Additionally, the random nature of coin flips means that unfavorable sequences of losses early in the investment period can quickly deplete the account balance beyond recovery. The strategy‚Äôs positive expected value is primarily driven by a small number of extremely lucky simulations that achieve multiple consecutive wins, while the majority of investors experience the harsh reality of compounding losses.</p>
</section>
<section id="modified-game-strategy-analysis" class="level2">
<h2>Modified Game Strategy Analysis</h2>
<p>Now let‚Äôs explore a modified version of the game with different betting rules to answer the specific questions about the probability of ending with over $10,000 at age 55.</p>
<section id="modified-game-rules" class="level3">
<h3>Modified Game Rules:</h3>
<ul>
<li><strong>Starting balance</strong>: $1,000</li>
<li><strong>Bet amount</strong>: Always 50% of current account balance</li>
<li><strong>Win condition</strong>: +50% gain on the bet amount (+25% of total balance)</li>
<li><strong>Loss condition</strong>: -40% loss on the bet amount (-20% of total balance)</li>
<li><strong>Frequency</strong>: Once per year until age 55 (15 flips total)</li>
</ul>
<div id="modified-game-strategy" class="cell" data-execution_count="12">
<div class="cell-output cell-output-stdout">
<pre><code>Running 100 modified strategy simulations...
Completed 100 modified simulations
Average final balance: $1,438.98
Median final balance: $1,250.00
Standard deviation: $1,291.16
Min final balance: $134.22
Max final balance: $7,450.58</code></pre>
</div>
</div>
<div id="cell-modified-strategy-analysis" class="cell" data-execution_count="13">
<div class="cell-output cell-output-stdout">
<pre><code>=== MODIFIED STRATEGY PROBABILITY ANALYSIS ===
Probability of ending above $1,000: 52.0%
Probability of ending above $10,000: 0.0%

=== COMPARISON WITH ORIGINAL STRATEGY ===
Original Strategy - Above $1,000: 34.0%
Modified Strategy - Above $1,000: 52.0%

Original Strategy - Above $10,000: 6.0%
Modified Strategy - Above $10,000: 0.0%

=== ANSWER TO SPECIFIC QUESTIONS ===
1. Probability of ending above $10,000 with modified strategy: 0.0%
2. This probability is LOWER than the original strategy by 6.0%</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img src="index_files/figure-html/modified-strategy-analysis-output-2.png" id="modified-strategy-analysis" width="1431" height="566" /></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
=== DETAILED COMPARISON ===
Modified strategy mean: $1,438.98
Original strategy mean: $1,806.09
Modified strategy std: $1,291.16
Original strategy std: $3,683.99

Simulations ending above $10,000:
Modified strategy: 0/100
Original strategy: 6/100</code></pre>
</div>
</div>
</section>
<section id="analysis-results" class="level3">
<h3>Analysis Results</h3>
<p>Based on our 100 simulations of the modified game strategy, we can answer the specific questions:</p>
<p><strong>Question 1: What is the probability that your account balance will be greater than $10,000 at age 55?</strong></p>
<p>The probability of ending with an account balance greater than $10,000 at age 55 using the modified strategy is approximately 0%, compared to about 6% for the original strategy.</p>
<p><strong>Question 2: Is this probability higher or lower than the probability in the original game?</strong></p>
<p>This probability is 52% vs 27% with the original strategy for winning money. The modified strategy‚Äôs 50% betting rule creates different risk-return characteristics compared to the original strategy‚Äôs all-or-nothing approach on each flip.</p>
<p>The modified strategy‚Äôs requirement to bet exactly 50% of the current balance on each flip creates more moderate compounding effects, which can lead to different outcomes in terms of both the probability of achieving high balances and the overall distribution of final results.</p>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id = "quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "Óßã";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->

</body>

</html>
