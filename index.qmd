---
title: "Simulation Challenge"
subtitle: "Generative Models and Monte Carlo Simulation"
format:
  html: default
  pdf: default
execute:
  echo: true
  eval: true
---

# ðŸŽ² Simulation Challenge - Monte Carlo Analysis

## Challenge Overview

**Your Mission:** Create a comprehensive Quarto document that simulates one or two investment strategies, analyzes the results, and demonstrates your ability to present counter-intuitive findings compellingly. Then render the document to HTML and deploy it via GitHub Pages from a new repository called "simulationChallenge."

## Investment Strategy Setup

### Strategy 1: Single Coin Flip Investment

```{python}
#| label: setup-imports
#| echo: true

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from typing import List, Tuple
import random

# Set random seed for reproducibility
np.random.seed(42)
random.seed(42)

print("Libraries imported successfully!")
```

```{python}
#| label: strategy-1-single-flip
#| echo: true

def single_coin_flip_strategy(initial_balance: float = 1000.0, 
                            win_probability: float = 0.5,
                            win_multiplier: float = 1.5,  # +50% gain
                            loss_multiplier: float = 0.6,  # -40% loss
                            num_simulations: int = 1000) -> List[float]:
    """
    Simulate the single coin flip investment strategy.
    
    Parameters:
    - initial_balance: Starting amount ($1000)
    - win_probability: Probability of winning (0.5 for fair coin)
    - win_multiplier: Multiplier when we win (1.5 = +50%)
    - loss_multiplier: Multiplier when we lose (0.6 = -40%)
    - num_simulations: Number of times to run the simulation
    
    Returns:
    - List of final balances for each simulation
    """
    final_balances = []
    
    for _ in range(num_simulations):
        balance = initial_balance
        
        # Single coin flip (0 or 1)
        coin_flip = random.random() < win_probability
        
        if coin_flip:  # Win: +50%
            balance *= win_multiplier
        else:  # Lose: -40%
            balance *= loss_multiplier
            
        final_balances.append(balance)
    
    return final_balances

# Test the function
test_results = single_coin_flip_strategy(num_simulations=10)
print(f"Sample results (first 10 simulations): {test_results}")
print(f"Average final balance: ${np.mean(test_results):.2f}")
```

```{python}
#| label: strategy-2-multiple-flips
#| echo: true

def multiple_coin_flips_strategy(initial_balance: float = 1000.0,
                               win_probability: float = 0.5,
                               win_multiplier: float = 1.5,  # +50% gain
                               loss_multiplier: float = 0.6,  # -40% loss
                               num_flips: int = 10,
                               num_simulations: int = 1000) -> List[float]:
    """
    Simulate multiple coin flip investment strategy.
    
    Parameters:
    - initial_balance: Starting amount ($1000)
    - win_probability: Probability of winning each flip (0.5 for fair coin)
    - win_multiplier: Multiplier when we win (1.5 = +50%)
    - loss_multiplier: Multiplier when we lose (0.6 = -40%)
    - num_flips: Number of coin flips per simulation
    - num_simulations: Number of times to run the simulation
    
    Returns:
    - List of final balances for each simulation
    """
    final_balances = []
    
    for _ in range(num_simulations):
        balance = initial_balance
        
        # Multiple coin flips
        for _ in range(num_flips):
            coin_flip = random.random() < win_probability
            
            if coin_flip:  # Win: +50%
                balance *= win_multiplier
            else:  # Lose: -40%
                balance *= loss_multiplier
                
        final_balances.append(balance)
    
    return final_balances

# Test the function
test_results_multiple = multiple_coin_flips_strategy(num_flips=5, num_simulations=10)
print(f"Sample results (5 flips, first 10 simulations): {test_results_multiple}")
print(f"Average final balance: ${np.mean(test_results_multiple):.2f}")
```

```{python}
#| label: analysis-functions
#| echo: true

def analyze_strategy_results(results: List[float], strategy_name: str) -> dict:
    """
    Analyze the results of a strategy simulation.
    
    Parameters:
    - results: List of final balances from simulations
    - strategy_name: Name of the strategy for display
    
    Returns:
    - Dictionary with analysis metrics
    """
    results_array = np.array(results)
    
    analysis = {
        'strategy': strategy_name,
        'mean_final_balance': np.mean(results_array),
        'median_final_balance': np.median(results_array),
        'std_final_balance': np.std(results_array),
        'min_final_balance': np.min(results_array),
        'max_final_balance': np.max(results_array),
        'win_rate': np.mean(results_array > 1000),  # Percentage above initial $1000
        'total_simulations': len(results_array)
    }
    
    return analysis

def print_analysis(analysis: dict):
    """Print formatted analysis results."""
    print(f"\n=== {analysis['strategy']} Analysis ===")
    print(f"Total Simulations: {analysis['total_simulations']:,}")
    print(f"Mean Final Balance: ${analysis['mean_final_balance']:.2f}")
    print(f"Median Final Balance: ${analysis['median_final_balance']:.2f}")
    print(f"Standard Deviation: ${analysis['std_final_balance']:.2f}")
    print(f"Min Final Balance: ${analysis['min_final_balance']:.2f}")
    print(f"Max Final Balance: ${analysis['max_final_balance']:.2f}")
    print(f"Win Rate (% above $1000): {analysis['win_rate']:.1%}")

# Test analysis functions
test_analysis = analyze_strategy_results(test_results, "Single Flip Test")
print_analysis(test_analysis)
```

```{python}
#| label: visualization-setup
#| echo: true

def create_strategy_visualizations(single_flip_results: List[float], 
                                 multiple_flip_results: List[float],
                                 num_flips: int = 10):
    """
    Create visualizations comparing the two strategies.
    
    Parameters:
    - single_flip_results: Results from single flip strategy
    - multiple_flip_results: Results from multiple flip strategy
    - num_flips: Number of flips used in multiple flip strategy
    """
    
    # Set up the plotting style
    plt.style.use('seaborn-v0_8')
    fig, axes = plt.subplots(2, 2, figsize=(15, 12))
    
    # 1. Histogram comparison
    axes[0, 0].hist(single_flip_results, bins=50, alpha=0.7, label='Single Flip', color='skyblue')
    axes[0, 0].hist(multiple_flip_results, bins=50, alpha=0.7, label=f'{num_flips} Flips', color='lightcoral')
    axes[0, 0].axvline(1000, color='black', linestyle='--', alpha=0.7, label='Initial $1000')
    axes[0, 0].set_xlabel('Final Balance ($)')
    axes[0, 0].set_ylabel('Frequency')
    axes[0, 0].set_title('Distribution of Final Balances')
    axes[0, 0].legend()
    axes[0, 0].grid(True, alpha=0.3)
    
    # 2. Box plot comparison
    data_to_plot = [single_flip_results, multiple_flip_results]
    labels = ['Single Flip', f'{num_flips} Flips']
    axes[0, 1].boxplot(data_to_plot, labels=labels)
    axes[0, 1].axhline(1000, color='black', linestyle='--', alpha=0.7, label='Initial $1000')
    axes[0, 1].set_ylabel('Final Balance ($)')
    axes[0, 1].set_title('Box Plot Comparison')
    axes[0, 1].legend()
    axes[0, 1].grid(True, alpha=0.3)
    
    # 3. Cumulative distribution
    single_sorted = np.sort(single_flip_results)
    multiple_sorted = np.sort(multiple_flip_results)
    single_cdf = np.arange(1, len(single_sorted) + 1) / len(single_sorted)
    multiple_cdf = np.arange(1, len(multiple_sorted) + 1) / len(multiple_sorted)
    
    axes[1, 0].plot(single_sorted, single_cdf, label='Single Flip', linewidth=2)
    axes[1, 0].plot(multiple_sorted, multiple_cdf, label=f'{num_flips} Flips', linewidth=2)
    axes[1, 0].axvline(1000, color='black', linestyle='--', alpha=0.7, label='Initial $1000')
    axes[1, 0].set_xlabel('Final Balance ($)')
    axes[1, 0].set_ylabel('Cumulative Probability')
    axes[1, 0].set_title('Cumulative Distribution Function')
    axes[1, 0].legend()
    axes[1, 0].grid(True, alpha=0.3)
    
    # 4. Log scale comparison
    axes[1, 1].hist(np.log10(single_flip_results), bins=50, alpha=0.7, label='Single Flip', color='skyblue')
    axes[1, 1].hist(np.log10(multiple_flip_results), bins=50, alpha=0.7, label=f'{num_flips} Flips', color='lightcoral')
    axes[1, 1].axvline(np.log10(1000), color='black', linestyle='--', alpha=0.7, label='Initial $1000')
    axes[1, 1].set_xlabel('Log10(Final Balance)')
    axes[1, 1].set_ylabel('Frequency')
    axes[1, 1].set_title('Distribution (Log Scale)')
    axes[1, 1].legend()
    axes[1, 1].grid(True, alpha=0.3)
    
    plt.tight_layout()
    return fig

print("Visualization functions defined successfully!")
```

## Single Simulation Analysis

Let's run a single simulation to see the dynamics of account balance over time:

```{python}
#| label: single-simulation-dynamics
#| echo: true

class InvestmentSimulation:
    """
    Object-oriented class for investment simulation with detailed tracking.
    """
    
    def __init__(self, initial_balance=1000.0, win_probability=0.5, 
                 win_multiplier=1.5, loss_multiplier=0.6):
        self.initial_balance = initial_balance
        self.win_probability = win_probability
        self.win_multiplier = win_multiplier
        self.loss_multiplier = loss_multiplier
        self.balance_history = []
        self.flip_results = []
        self.flip_numbers = []
        
    def run_single_simulation(self, num_flips=20):
        """
        Run a single simulation with detailed tracking of each flip.
        
        Parameters:
        - num_flips: Number of coin flips to simulate
        
        Returns:
        - Dictionary with simulation results
        """
        # Reset history
        self.balance_history = [self.initial_balance]
        self.flip_results = []
        self.flip_numbers = []
        
        current_balance = self.initial_balance
        
        for flip in range(1, num_flips + 1):
            # Simulate coin flip
            coin_flip = random.random() < self.win_probability
            
            if coin_flip:  # Win: +50%
                current_balance *= self.win_multiplier
                result = "WIN"
            else:  # Lose: -40%
                current_balance *= self.loss_multiplier
                result = "LOSS"
            
            # Record results
            self.balance_history.append(current_balance)
            self.flip_results.append(result)
            self.flip_numbers.append(flip)
        
        return {
            'final_balance': current_balance,
            'total_gain_loss': current_balance - self.initial_balance,
            'total_gain_loss_pct': ((current_balance - self.initial_balance) / self.initial_balance) * 100,
            'wins': self.flip_results.count("WIN"),
            'losses': self.flip_results.count("LOSS"),
            'win_rate': self.flip_results.count("WIN") / len(self.flip_results)
        }
    
    def plot_balance_dynamics(self, figsize=(12, 8), style='seaborn-v0_8'):
        """
        Create an object-oriented matplotlib visualization of balance dynamics.
        
        Parameters:
        - figsize: Figure size tuple
        - style: Matplotlib style
        """
        plt.style.use(style)
        
        # Create figure and axis objects
        fig = plt.Figure(figsize=figsize)
        gs = fig.add_gridspec(2, 2, height_ratios=[2, 1], width_ratios=[3, 1], 
                             hspace=0.3, wspace=0.3)
        
        # Main balance plot
        ax_main = fig.add_subplot(gs[0, :])
        ax_main.plot(self.flip_numbers, self.balance_history[1:], 
                    linewidth=2.5, color='#2E86AB', marker='o', markersize=4)
        ax_main.axhline(y=self.initial_balance, color='red', linestyle='--', 
                       alpha=0.7, linewidth=2, label=f'Initial Balance (${self.initial_balance:,.0f})')
        ax_main.set_xlabel('Coin Flip Number', fontsize=12, fontweight='bold')
        ax_main.set_ylabel('Account Balance ($)', fontsize=12, fontweight='bold')
        ax_main.set_title('Account Balance Dynamics Over Time', fontsize=14, fontweight='bold')
        ax_main.grid(True, alpha=0.3)
        ax_main.legend(fontsize=10)
        
        # Color-code the line based on wins/losses
        for i, (flip_num, balance, result) in enumerate(zip(self.flip_numbers, 
                                                          self.balance_history[1:], 
                                                          self.flip_results)):
            color = '#28A745' if result == 'WIN' else '#DC3545'
            ax_main.scatter(flip_num, balance, color=color, s=30, alpha=0.8, zorder=5)
        
        # Balance distribution histogram
        ax_hist = fig.add_subplot(gs[1, 0])
        ax_hist.hist(self.balance_history[1:], bins=15, alpha=0.7, color='skyblue', 
                    edgecolor='black', linewidth=0.5)
        ax_hist.axvline(self.initial_balance, color='red', linestyle='--', 
                       alpha=0.7, linewidth=2, label='Initial Balance')
        ax_hist.set_xlabel('Account Balance ($)', fontsize=10)
        ax_hist.set_ylabel('Frequency', fontsize=10)
        ax_hist.set_title('Balance Distribution', fontsize=12, fontweight='bold')
        ax_hist.legend(fontsize=8)
        ax_hist.grid(True, alpha=0.3)
        
        # Statistics panel
        ax_stats = fig.add_subplot(gs[1, 1])
        ax_stats.axis('off')
        
        # Calculate statistics
        final_balance = self.balance_history[-1]
        total_change = final_balance - self.initial_balance
        total_change_pct = (total_change / self.initial_balance) * 100
        wins = self.flip_results.count("WIN")
        losses = self.flip_results.count("LOSS")
        win_rate = wins / len(self.flip_results) * 100
        
        # Create statistics text
        stats_text = f"""
        SIMULATION STATISTICS
        
        Initial Balance: ${self.initial_balance:,.0f}
        Final Balance: ${final_balance:,.2f}
        
        Total Change: ${total_change:+,.2f}
        Change %: {total_change_pct:+.1f}%
        
        Wins: {wins}
        Losses: {losses}
        Win Rate: {win_rate:.1f}%
        
        Max Balance: ${max(self.balance_history):,.2f}
        Min Balance: ${min(self.balance_history):,.2f}
        """
        
        ax_stats.text(0.05, 0.95, stats_text, transform=ax_stats.transAxes, 
                     fontsize=9, verticalalignment='top', fontfamily='monospace',
                     bbox=dict(boxstyle='round,pad=0.5', facecolor='lightgray', alpha=0.8))
        
        return fig

# Run a single simulation
simulation = InvestmentSimulation()
results = simulation.run_single_simulation(num_flips=15)

print("=== SINGLE SIMULATION RESULTS ===")
print(f"Initial Balance: ${simulation.initial_balance:,.0f}")
print(f"Final Balance: ${results['final_balance']:,.2f}")
print(f"Total Change: ${results['total_gain_loss']:+,.2f} ({results['total_gain_loss_pct']:+.1f}%)")
print(f"Wins: {results['wins']}, Losses: {results['losses']}")
print(f"Win Rate: {results['win_rate']:.1%}")
print(f"Flip Results: {' '.join(simulation.flip_results)}")
```

```{python}
#| label: create-balance-visualization
#| echo: true

# Create the object-oriented matplotlib visualization
fig = simulation.plot_balance_dynamics(figsize=(14, 10))

# Display the figure
plt.show()

# Print additional insights
print("\n=== BALANCE DYNAMICS INSIGHTS ===")
print(f"Peak Balance: ${max(simulation.balance_history):,.2f}")
print(f"Lowest Balance: ${min(simulation.balance_history):,.2f}")
print(f"Largest Single Gain: ${max([simulation.balance_history[i+1] - simulation.balance_history[i] for i in range(len(simulation.balance_history)-1)]):,.2f}")
print(f"Largest Single Loss: ${min([simulation.balance_history[i+1] - simulation.balance_history[i] for i in range(len(simulation.balance_history)-1)]):,.2f}")

# Show the balance progression
print(f"\nBalance Progression:")
for i, balance in enumerate(simulation.balance_history):
    if i == 0:
        print(f"Start: ${balance:,.2f}")
    else:
        change = balance - simulation.balance_history[i-1]
        change_pct = (change / simulation.balance_history[i-1]) * 100
        print(f"Flip {i}: ${balance:,.2f} ({change:+.2f}, {change_pct:+.1f}%)")
```

## Ready for Simulation

The code is now set up with two investment strategies:

1. **Single Coin Flip Strategy**: One flip, win +50% or lose -40%
2. **Multiple Coin Flips Strategy**: Multiple flips with the same win/loss percentages

**Key Parameters:**
- Initial balance: $1,000
- Win probability: 50% (fair coin)
- Win multiplier: 1.5 (+50% gain)
- Loss multiplier: 0.6 (-40% loss)

The code includes analysis functions and visualization tools ready to use once you specify the simulation parameters you'd like to test!

## Analysis Questions

### 1. Expected Value Calculation
**What is the expected value of the final balance for the single coin flip strategy?**

For a single coin flip:
- Win probability: 50% (0.5)
- Win multiplier: 1.5 (+50% gain)
- Loss multiplier: 0.6 (-40% loss)

**Expected Value = (0.5 Ã— 1.5) + (0.5 Ã— 0.6) = 0.75 + 0.30 = 1.05**

This means the expected final balance is **$1,050** (5% expected gain per flip).

### 2. Expectation vs Reality
**Is the expected value positive or negative?**

The expected value is **positive** (1.05 > 1.0), meaning we expect to gain money on average. However, this doesn't guarantee profit in any single simulation due to the high variance of the strategy.

**Key Insight**: While the expected value is positive, the high volatility means individual simulations can vary dramatically from this expectation. 

3. Single Simulation: 

```{python}
#| label: single-simulation-dynamics
#| echo: true

class InvestmentSimulation:
    """
    Object-oriented class for investment simulation with detailed tracking.
    """
    
    def __init__(self, initial_balance=1000.0, win_probability=0.5, 
                 win_multiplier=1.5, loss_multiplier=0.6):
        self.initial_balance = initial_balance
        self.win_probability = win_probability
        self.win_multiplier = win_multiplier
        self.loss_multiplier = loss_multiplier
        self.balance_history = []
        self.flip_results = []
        self.flip_numbers = []
        
    def run_single_simulation(self, num_flips=20):
        """
        Run a single simulation with detailed tracking of each flip.
        
        Parameters:
        - num_flips: Number of coin flips to simulate
        
        Returns:
        - Dictionary with simulation results
        """
        # Reset history
        self.balance_history = [self.initial_balance]
        self.flip_results = []
        self.flip_numbers = []
        
        current_balance = self.initial_balance
        
        for flip in range(1, num_flips + 1):
            # Simulate coin flip
            coin_flip = random.random() < self.win_probability
            
            if coin_flip:  # Win: +50%
                current_balance *= self.win_multiplier
                result = "WIN"
            else:  # Lose: -40%
                current_balance *= self.loss_multiplier
                result = "LOSS"
            
            # Record results
            self.balance_history.append(current_balance)
            self.flip_results.append(result)
            self.flip_numbers.append(flip)
        
        return {
            'final_balance': current_balance,
            'total_gain_loss': current_balance - self.initial_balance,
            'total_gain_loss_pct': ((current_balance - self.initial_balance) / self.initial_balance) * 100,
            'wins': self.flip_results.count("WIN"),
            'losses': self.flip_results.count("LOSS"),
            'win_rate': self.flip_results.count("WIN") / len(self.flip_results)
        }
    
    def plot_balance_dynamics(self, figsize=(12, 8), style='seaborn-v0_8'):
        """
        Create an object-oriented matplotlib visualization of balance dynamics.
        
        Parameters:
        - figsize: Figure size tuple
        - style: Matplotlib style
        """
        plt.style.use(style)
        
        # Create figure and axis objects
        fig = plt.Figure(figsize=figsize)
        gs = fig.add_gridspec(2, 2, height_ratios=[2, 1], width_ratios=[3, 1], 
                             hspace=0.3, wspace=0.3)
        
        # Main balance plot
        ax_main = fig.add_subplot(gs[0, :])
        ax_main.plot(self.flip_numbers, self.balance_history[1:], 
                    linewidth=2.5, color='#2E86AB', marker='o', markersize=4)
        ax_main.axhline(y=self.initial_balance, color='red', linestyle='--', 
                       alpha=0.7, linewidth=2, label=f'Initial Balance (${self.initial_balance:,.0f})')
        ax_main.set_xlabel('Coin Flip Number', fontsize=12, fontweight='bold')
        ax_main.set_ylabel('Account Balance ($)', fontsize=12, fontweight='bold')
        ax_main.set_title('Account Balance Dynamics Over Time', fontsize=14, fontweight='bold')
        ax_main.grid(True, alpha=0.3)
        ax_main.legend(fontsize=10)
        
        # Color-code the line based on wins/losses
        for i, (flip_num, balance, result) in enumerate(zip(self.flip_numbers, 
                                                          self.balance_history[1:], 
                                                          self.flip_results)):
            color = '#28A745' if result == 'WIN' else '#DC3545'
            ax_main.scatter(flip_num, balance, color=color, s=30, alpha=0.8, zorder=5)
        
        # Balance distribution histogram
        ax_hist = fig.add_subplot(gs[1, 0])
        ax_hist.hist(self.balance_history[1:], bins=15, alpha=0.7, color='skyblue', 
                    edgecolor='black', linewidth=0.5)
        ax_hist.axvline(self.initial_balance, color='red', linestyle='--', 
                       alpha=0.7, linewidth=2, label='Initial Balance')
        ax_hist.set_xlabel('Account Balance ($)', fontsize=10)
        ax_hist.set_ylabel('Frequency', fontsize=10)
        ax_hist.set_title('Balance Distribution', fontsize=12, fontweight='bold')
        ax_hist.legend(fontsize=8)
        ax_hist.grid(True, alpha=0.3)
        
        # Statistics panel
        ax_stats = fig.add_subplot(gs[1, 1])
        ax_stats.axis('off')
        
        # Calculate statistics
        final_balance = self.balance_history[-1]
        total_change = final_balance - self.initial_balance
        total_change_pct = (total_change / self.initial_balance) * 100
        wins = self.flip_results.count("WIN")
        losses = self.flip_results.count("LOSS")
        win_rate = wins / len(self.flip_results) * 100
        
        # Create statistics text
        stats_text = f"""
        SIMULATION STATISTICS
        
        Initial Balance: ${self.initial_balance:,.0f}
        Final Balance: ${final_balance:,.2f}
        
        Total Change: ${total_change:+,.2f}
        Change %: {total_change_pct:+.1f}%
        
        Wins: {wins}
        Losses: {losses}
        Win Rate: {win_rate:.1f}%
        
        Max Balance: ${max(self.balance_history):,.2f}
        Min Balance: ${min(self.balance_history):,.2f}
        """
        
        ax_stats.text(0.05, 0.95, stats_text, transform=ax_stats.transAxes, 
                     fontsize=9, verticalalignment='top', fontfamily='monospace',
                     bbox=dict(boxstyle='round,pad=0.5', facecolor='lightgray', alpha=0.8))
        
        return fig

# Run a single simulation
simulation = InvestmentSimulation()
results = simulation.run_single_simulation(num_flips=15)

print("=== SINGLE SIMULATION RESULTS ===")
print(f"Initial Balance: ${simulation.initial_balance:,.0f}")
print(f"Final Balance: ${results['final_balance']:,.2f}")
print(f"Total Change: ${results['total_gain_loss']:+,.2f} ({results['total_gain_loss_pct']:+.1f}%)")
print(f"Wins: {results['wins']}, Losses: {results['losses']}")
print(f"Win Rate: {results['win_rate']:.1%}")
print(f"Flip Results: {' '.join(simulation.flip_results)}")
```

```{python}
#| label: create-balance-visualization
#| echo: true

# Create the object-oriented matplotlib visualization
fig = simulation.plot_balance_dynamics(figsize=(14, 10))

# Display the figure
plt.show()

# Print additional insights
print("\n=== BALANCE DYNAMICS INSIGHTS ===")
print(f"Peak Balance: ${max(simulation.balance_history):,.2f}")
print(f"Lowest Balance: ${min(simulation.balance_history):,.2f}")
print(f"Largest Single Gain: ${max([simulation.balance_history[i+1] - simulation.balance_history[i] for i in range(len(simulation.balance_history)-1)]):,.2f}")
print(f"Largest Single Loss: ${min([simulation.balance_history[i+1] - simulation.balance_history[i] for i in range(len(simulation.balance_history)-1)]):,.2f}")

# Show the balance progression
print(f"\nBalance Progression:")
for i, balance in enumerate(simulation.balance_history):
    if i == 0:
        print(f"Start: ${balance:,.2f}")
    else:
        change = balance - simulation.balance_history[i-1]
        change_pct = (change / simulation.balance_history[i-1]) * 100
        print(f"Flip {i}: ${balance:,.2f} ({change:+.2f}, {change_pct:+.1f}%)")
```

We ended up with $286.98 and lost 71.3% of our initial balance. I would not be happy with this result as clearly we lost a lot of money. We would need to run more simulations to get closer to the expected value.

