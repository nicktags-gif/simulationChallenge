---
title: "Simulation Challenge"
subtitle: "Generative Models and Monte Carlo Simulation"
format:
  html: default
  pdf: default
execute:
  echo: true
  eval: true
---

# ðŸŽ² Simulation Challenge - Monte Carlo Analysis

## Challenge Overview

**Your Mission:** Create a comprehensive Quarto document that simulates one or two investment strategies, analyzes the results, and demonstrates your ability to present counter-intuitive findings compellingly. Then render the document to HTML and deploy it via GitHub Pages from a new repository called "simulationChallenge."

## Investment Strategy Setup

### Strategy 1: Single Coin Flip Investment

```{python}
#| label: setup-imports
#| echo: false

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from typing import List, Tuple
import random

# Set random seed for reproducibility
np.random.seed(42)
random.seed(42)

print("Libraries imported successfully!")
```

```{python}
#| label: strategy-1-single-flip
#| echo: false

def single_coin_flip_strategy(initial_balance: float = 1000.0, 
                            win_probability: float = 0.5,
                            win_multiplier: float = 1.5,  # +50% gain
                            loss_multiplier: float = 0.6,  # -40% loss
                            num_simulations: int = 1000) -> List[float]:
    """
    Simulate the single coin flip investment strategy.
    
    Parameters:
    - initial_balance: Starting amount ($1000)
    - win_probability: Probability of winning (0.5 for fair coin)
    - win_multiplier: Multiplier when we win (1.5 = +50%)
    - loss_multiplier: Multiplier when we lose (0.6 = -40%)
    - num_simulations: Number of times to run the simulation
    
    Returns:
    - List of final balances for each simulation
    """
    final_balances = []
    
    for _ in range(num_simulations):
        balance = initial_balance
        
        # Single coin flip (0 or 1)
        coin_flip = random.random() < win_probability
        
        if coin_flip:  # Win: +50%
            balance *= win_multiplier
        else:  # Lose: -40%
            balance *= loss_multiplier
            
        final_balances.append(balance)
    
    return final_balances

# Test the function
test_results = single_coin_flip_strategy(num_simulations=10)
print(f"Sample results (first 10 simulations): {test_results}")
print(f"Average final balance: ${np.mean(test_results):.2f}")
```

```{python}
#| label: strategy-2-multiple-flips
#| echo: false

def multiple_coin_flips_strategy(initial_balance: float = 1000.0,
                               win_probability: float = 0.5,
                               win_multiplier: float = 1.5,  # +50% gain
                               loss_multiplier: float = 0.6,  # -40% loss
                               num_flips: int = 10,
                               num_simulations: int = 1000) -> List[float]:
    """
    Simulate multiple coin flip investment strategy.
    
    Parameters:
    - initial_balance: Starting amount ($1000)
    - win_probability: Probability of winning each flip (0.5 for fair coin)
    - win_multiplier: Multiplier when we win (1.5 = +50%)
    - loss_multiplier: Multiplier when we lose (0.6 = -40%)
    - num_flips: Number of coin flips per simulation
    - num_simulations: Number of times to run the simulation
    
    Returns:
    - List of final balances for each simulation
    """
    final_balances = []
    
    for _ in range(num_simulations):
        balance = initial_balance
        
        # Multiple coin flips
        for _ in range(num_flips):
            coin_flip = random.random() < win_probability
            
            if coin_flip:  # Win: +50%
                balance *= win_multiplier
            else:  # Lose: -40%
                balance *= loss_multiplier
                
        final_balances.append(balance)
    
    return final_balances

# Test the function
test_results_multiple = multiple_coin_flips_strategy(num_flips=5, num_simulations=10)
print(f"Sample results (5 flips, first 10 simulations): {test_results_multiple}")
print(f"Average final balance: ${np.mean(test_results_multiple):.2f}")
```

```{python}
#| label: analysis-functions
#| echo: false

def analyze_strategy_results(results: List[float], strategy_name: str) -> dict:
    """
    Analyze the results of a strategy simulation.
    
    Parameters:
    - results: List of final balances from simulations
    - strategy_name: Name of the strategy for display
    
    Returns:
    - Dictionary with analysis metrics
    """
    results_array = np.array(results)
    
    analysis = {
        'strategy': strategy_name,
        'mean_final_balance': np.mean(results_array),
        'median_final_balance': np.median(results_array),
        'std_final_balance': np.std(results_array),
        'min_final_balance': np.min(results_array),
        'max_final_balance': np.max(results_array),
        'win_rate': np.mean(results_array > 1000),  # Percentage above initial $1000
        'total_simulations': len(results_array)
    }
    
    return analysis

def print_analysis(analysis: dict):
    """Print formatted analysis results."""
    print(f"\n=== {analysis['strategy']} Analysis ===")
    print(f"Total Simulations: {analysis['total_simulations']:,}")
    print(f"Mean Final Balance: ${analysis['mean_final_balance']:.2f}")
    print(f"Median Final Balance: ${analysis['median_final_balance']:.2f}")
    print(f"Standard Deviation: ${analysis['std_final_balance']:.2f}")
    print(f"Min Final Balance: ${analysis['min_final_balance']:.2f}")
    print(f"Max Final Balance: ${analysis['max_final_balance']:.2f}")
    print(f"Win Rate (% above $1000): {analysis['win_rate']:.1%}")

# Test analysis functions
test_analysis = analyze_strategy_results(test_results, "Single Flip Test")
print_analysis(test_analysis)
```

```{python}
#| label: visualization-setup
#| echo: false

def create_strategy_visualizations(single_flip_results: List[float], 
                                 multiple_flip_results: List[float],
                                 num_flips: int = 10):
    """
    Create visualizations comparing the two strategies.
    
    Parameters:
    - single_flip_results: Results from single flip strategy
    - multiple_flip_results: Results from multiple flip strategy
    - num_flips: Number of flips used in multiple flip strategy
    """
    
    # Set up the plotting style
    plt.style.use('seaborn-v0_8')
    fig, axes = plt.subplots(2, 2, figsize=(15, 12))
    
    # 1. Histogram comparison
    axes[0, 0].hist(single_flip_results, bins=50, alpha=0.7, label='Single Flip', color='skyblue')
    axes[0, 0].hist(multiple_flip_results, bins=50, alpha=0.7, label=f'{num_flips} Flips', color='lightcoral')
    axes[0, 0].axvline(1000, color='black', linestyle='--', alpha=0.7, label='Initial $1000')
    axes[0, 0].set_xlabel('Final Balance ($)')
    axes[0, 0].set_ylabel('Frequency')
    axes[0, 0].set_title('Distribution of Final Balances')
    axes[0, 0].legend()
    axes[0, 0].grid(True, alpha=0.3)
    
    # 2. Box plot comparison
    data_to_plot = [single_flip_results, multiple_flip_results]
    labels = ['Single Flip', f'{num_flips} Flips']
    axes[0, 1].boxplot(data_to_plot, labels=labels)
    axes[0, 1].axhline(1000, color='black', linestyle='--', alpha=0.7, label='Initial $1000')
    axes[0, 1].set_ylabel('Final Balance ($)')
    axes[0, 1].set_title('Box Plot Comparison')
    axes[0, 1].legend()
    axes[0, 1].grid(True, alpha=0.3)
    
    # 3. Cumulative distribution
    single_sorted = np.sort(single_flip_results)
    multiple_sorted = np.sort(multiple_flip_results)
    single_cdf = np.arange(1, len(single_sorted) + 1) / len(single_sorted)
    multiple_cdf = np.arange(1, len(multiple_sorted) + 1) / len(multiple_sorted)
    
    axes[1, 0].plot(single_sorted, single_cdf, label='Single Flip', linewidth=2)
    axes[1, 0].plot(multiple_sorted, multiple_cdf, label=f'{num_flips} Flips', linewidth=2)
    axes[1, 0].axvline(1000, color='black', linestyle='--', alpha=0.7, label='Initial $1000')
    axes[1, 0].set_xlabel('Final Balance ($)')
    axes[1, 0].set_ylabel('Cumulative Probability')
    axes[1, 0].set_title('Cumulative Distribution Function')
    axes[1, 0].legend()
    axes[1, 0].grid(True, alpha=0.3)
    
    # 4. Log scale comparison
    axes[1, 1].hist(np.log10(single_flip_results), bins=50, alpha=0.7, label='Single Flip', color='skyblue')
    axes[1, 1].hist(np.log10(multiple_flip_results), bins=50, alpha=0.7, label=f'{num_flips} Flips', color='lightcoral')
    axes[1, 1].axvline(np.log10(1000), color='black', linestyle='--', alpha=0.7, label='Initial $1000')
    axes[1, 1].set_xlabel('Log10(Final Balance)')
    axes[1, 1].set_ylabel('Frequency')
    axes[1, 1].set_title('Distribution (Log Scale)')
    axes[1, 1].legend()
    axes[1, 1].grid(True, alpha=0.3)
    
    plt.tight_layout()
    return fig

print("Visualization functions defined successfully!")
```


## Analysis Questions

### 1. Expected Value Calculation
**What is the expected value of the final balance for the single coin flip strategy?**

For a single coin flip:
- Win probability: 50% (0.5)
- Win multiplier: 1.5 (+50% gain)
- Loss multiplier: 0.6 (-40% loss)

**Expected Value = (0.5 Ã— 1.5) + (0.5 Ã— 0.6) = 0.75 + 0.30 = 1.05**

This means the expected final balance is **$1,050** (5% expected gain per flip).

### 2. Expectation vs Reality
**Is the expected value positive or negative?**

The expected value is **positive** (1.05 > 1.0), meaning we expect to gain money on average. However, this doesn't guarantee profit in any single simulation due to the high variance of the strategy.

**Key Insight**: While the expected value is positive, the high volatility means individual simulations can vary dramatically from this expectation. 

3. Single Simulation: 

```{python}
#| label: single-simulation-dynamics
#| echo: false

class InvestmentSimulation:
    """
    Object-oriented class for investment simulation with detailed tracking.
    """
    
    def __init__(self, initial_balance=1000.0, win_probability=0.5, 
                 win_multiplier=1.5, loss_multiplier=0.6):
        self.initial_balance = initial_balance
        self.win_probability = win_probability
        self.win_multiplier = win_multiplier
        self.loss_multiplier = loss_multiplier
        self.balance_history = []
        self.flip_results = []
        self.flip_numbers = []
        
    def run_single_simulation(self, num_flips=20):
        """
        Run a single simulation with detailed tracking of each flip.
        
        Parameters:
        - num_flips: Number of coin flips to simulate
        
        Returns:
        - Dictionary with simulation results
        """
        # Reset history
        self.balance_history = [self.initial_balance]
        self.flip_results = []
        self.flip_numbers = []
        
        current_balance = self.initial_balance
        
        for flip in range(1, num_flips + 1):
            # Simulate coin flip
            coin_flip = random.random() < self.win_probability
            
            if coin_flip:  # Win: +50%
                current_balance *= self.win_multiplier
                result = "WIN"
            else:  # Lose: -40%
                current_balance *= self.loss_multiplier
                result = "LOSS"
            
            # Record results
            self.balance_history.append(current_balance)
            self.flip_results.append(result)
            self.flip_numbers.append(flip)
        
        return {
            'final_balance': current_balance,
            'total_gain_loss': current_balance - self.initial_balance,
            'total_gain_loss_pct': ((current_balance - self.initial_balance) / self.initial_balance) * 100,
            'wins': self.flip_results.count("WIN"),
            'losses': self.flip_results.count("LOSS"),
            'win_rate': self.flip_results.count("WIN") / len(self.flip_results)
        }
    
    def plot_balance_dynamics(self, figsize=(12, 8), style='seaborn-v0_8'):
        """
        Create an object-oriented matplotlib visualization of balance dynamics.
        
        Parameters:
        - figsize: Figure size tuple
        - style: Matplotlib style
        """
        plt.style.use(style)
        
        # Create figure and axis objects
        fig = plt.Figure(figsize=figsize)
        gs = fig.add_gridspec(2, 2, height_ratios=[2, 1], width_ratios=[3, 1], 
                             hspace=0.3, wspace=0.3)
        
        # Main balance plot
        ax_main = fig.add_subplot(gs[0, :])
        ax_main.plot(self.flip_numbers, self.balance_history[1:], 
                    linewidth=2.5, color='#2E86AB', marker='o', markersize=4)
        ax_main.axhline(y=self.initial_balance, color='red', linestyle='--', 
                       alpha=0.7, linewidth=2, label=f'Initial Balance (${self.initial_balance:,.0f})')
        ax_main.set_xlabel('Coin Flip Number', fontsize=12, fontweight='bold')
        ax_main.set_ylabel('Account Balance ($)', fontsize=12, fontweight='bold')
        ax_main.set_title('Account Balance Dynamics Over Time', fontsize=14, fontweight='bold')
        ax_main.grid(True, alpha=0.3)
        ax_main.legend(fontsize=10)
        
        # Color-code the line based on wins/losses
        for i, (flip_num, balance, result) in enumerate(zip(self.flip_numbers, 
                                                          self.balance_history[1:], 
                                                          self.flip_results)):
            color = '#28A745' if result == 'WIN' else '#DC3545'
            ax_main.scatter(flip_num, balance, color=color, s=30, alpha=0.8, zorder=5)
        
        # Balance distribution histogram
        ax_hist = fig.add_subplot(gs[1, 0])
        ax_hist.hist(self.balance_history[1:], bins=15, alpha=0.7, color='skyblue', 
                    edgecolor='black', linewidth=0.5)
        ax_hist.axvline(self.initial_balance, color='red', linestyle='--', 
                       alpha=0.7, linewidth=2, label='Initial Balance')
        ax_hist.set_xlabel('Account Balance ($)', fontsize=10)
        ax_hist.set_ylabel('Frequency', fontsize=10)
        ax_hist.set_title('Balance Distribution', fontsize=12, fontweight='bold')
        ax_hist.legend(fontsize=8)
        ax_hist.grid(True, alpha=0.3)
        
        # Statistics panel
        ax_stats = fig.add_subplot(gs[1, 1])
        ax_stats.axis('off')
        
        # Calculate statistics
        final_balance = self.balance_history[-1]
        total_change = final_balance - self.initial_balance
        total_change_pct = (total_change / self.initial_balance) * 100
        wins = self.flip_results.count("WIN")
        losses = self.flip_results.count("LOSS")
        win_rate = wins / len(self.flip_results) * 100
        
        # Create statistics text
        stats_text = f"""
        SIMULATION STATISTICS
        
        Initial Balance: ${self.initial_balance:,.0f}
        Final Balance: ${final_balance:,.2f}
        
        Total Change: ${total_change:+,.2f}
        Change %: {total_change_pct:+.1f}%
        
        Wins: {wins}
        Losses: {losses}
        Win Rate: {win_rate:.1f}%
        
        Max Balance: ${max(self.balance_history):,.2f}
        Min Balance: ${min(self.balance_history):,.2f}
        """
        
        ax_stats.text(0.05, 0.95, stats_text, transform=ax_stats.transAxes, 
                     fontsize=9, verticalalignment='top', fontfamily='monospace',
                     bbox=dict(boxstyle='round,pad=0.5', facecolor='lightgray', alpha=0.8))
        
        return fig

# Run a single simulation
simulation = InvestmentSimulation()
results = simulation.run_single_simulation(num_flips=15)

print("=== SINGLE SIMULATION RESULTS ===")
print(f"Initial Balance: ${simulation.initial_balance:,.0f}")
print(f"Final Balance: ${results['final_balance']:,.2f}")
print(f"Total Change: ${results['total_gain_loss']:+,.2f} ({results['total_gain_loss_pct']:+.1f}%)")
print(f"Wins: {results['wins']}, Losses: {results['losses']}")
print(f"Win Rate: {results['win_rate']:.1%}")
print(f"Flip Results: {' '.join(simulation.flip_results)}")
```

```{python}
#| label: create-balance-visualization
#| echo: false

# Create the object-oriented matplotlib visualization
fig = simulation.plot_balance_dynamics(figsize=(14, 10))

# Display the figure
plt.show()

# Print additional insights
print("\n=== BALANCE DYNAMICS INSIGHTS ===")
print(f"Peak Balance: ${max(simulation.balance_history):,.2f}")
print(f"Lowest Balance: ${min(simulation.balance_history):,.2f}")
print(f"Largest Single Gain: ${max([simulation.balance_history[i+1] - simulation.balance_history[i] for i in range(len(simulation.balance_history)-1)]):,.2f}")
print(f"Largest Single Loss: ${min([simulation.balance_history[i+1] - simulation.balance_history[i] for i in range(len(simulation.balance_history)-1)]):,.2f}")

# Create a matplotlib visualization of balance changes over time
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10))

# Plot 1: Balance progression over time
flip_numbers = list(range(len(simulation.balance_history)))
ax1.plot(flip_numbers, simulation.balance_history, 'o-', linewidth=2, markersize=6, color='#2E86AB')
ax1.axhline(y=simulation.initial_balance, color='red', linestyle='--', alpha=0.7, linewidth=2, label=f'Initial Balance (${simulation.initial_balance:,.0f})')
ax1.set_xlabel('Coin Flip Number', fontsize=12, fontweight='bold')
ax1.set_ylabel('Account Balance ($)', fontsize=12, fontweight='bold')
ax1.set_title('Account Balance Progression Over Time', fontsize=14, fontweight='bold')
ax1.grid(True, alpha=0.3)
ax1.legend(fontsize=10)

# Color-code points based on wins/losses
for i, (flip_num, balance, result) in enumerate(zip(flip_numbers[1:], simulation.balance_history[1:], simulation.flip_results)):
    color = '#28A745' if result == 'WIN' else '#DC3545'
    ax1.scatter(flip_num, balance, color=color, s=50, alpha=0.8, zorder=5)

# Plot 2: Balance changes (gains/losses) per flip
balance_changes = []
change_percentages = []
for i in range(1, len(simulation.balance_history)):
    change = simulation.balance_history[i] - simulation.balance_history[i-1]
    change_pct = (change / simulation.balance_history[i-1]) * 100
    balance_changes.append(change)
    change_percentages.append(change_pct)

flip_numbers_changes = list(range(1, len(simulation.balance_history)))
colors = ['#28A745' if change > 0 else '#DC3545' for change in balance_changes]

ax2.bar(flip_numbers_changes, balance_changes, color=colors, alpha=0.7, edgecolor='black', linewidth=0.5)
ax2.axhline(y=0, color='black', linestyle='-', alpha=0.5)
ax2.set_xlabel('Coin Flip Number', fontsize=12, fontweight='bold')
ax2.set_ylabel('Balance Change ($)', fontsize=12, fontweight='bold')
ax2.set_title('Balance Changes Per Coin Flip', fontsize=14, fontweight='bold')
ax2.grid(True, alpha=0.3, axis='y')

# Add value labels on bars
for i, (flip_num, change, change_pct) in enumerate(zip(flip_numbers_changes, balance_changes, change_percentages)):
    ax2.text(flip_num, change + (5 if change > 0 else -15), f'${change:+.0f}\n({change_pct:+.1f}%)', 
             ha='center', va='bottom' if change > 0 else 'top', fontsize=8, fontweight='bold')

plt.tight_layout()
plt.show()

# Print summary statistics
print(f"\n=== BALANCE CHANGES SUMMARY ===")
print(f"Largest Single Gain: ${max(balance_changes):,.2f} ({max(change_percentages):+.1f}%)")
print(f"Largest Single Loss: ${min(balance_changes):,.2f} ({min(change_percentages):+.1f}%)")
print(f"Average Change per Flip: ${np.mean(balance_changes):,.2f} ({np.mean(change_percentages):+.1f}%)")
print(f"Total Gains: ${sum([c for c in balance_changes if c > 0]):,.2f}")
print(f"Total Losses: ${sum([c for c in balance_changes if c < 0]):,.2f}")
print(f"Net Change: ${sum(balance_changes):,.2f}")
```

We ended up with a net change of $-885.21. I would not be happy with this result, as we were losing more than we expected. With the 15 flips, we were definitely unlucky with the amount of times we lost, but it showed the law of large numbers at work where if we ran the simulation many times, we would get closer to the expected value.

## 100 Simulations Analysis

Now let's run 100 simulations to get a better understanding of the distribution of outcomes and create a probability distribution plot of final account balances.

```{python}
#| label: hundred-simulations
#| echo: false

def run_multiple_simulations(num_simulations=100, num_flips=15, initial_balance=1000.0):
    """
    Run multiple simulations and collect final balances.
    
    Parameters:
    - num_simulations: Number of simulations to run
    - num_flips: Number of coin flips per simulation
    - initial_balance: Starting balance
    
    Returns:
    - List of final balances from all simulations
    - List of simulation objects for detailed analysis
    """
    final_balances = []
    simulation_objects = []
    
    for i in range(num_simulations):
        # Set individual seed for each simulation to ensure reproducibility
        np.random.seed(42 + i)
        random.seed(42 + i)
        
        sim = InvestmentSimulation(initial_balance=initial_balance)
        results = sim.run_single_simulation(num_flips=num_flips)
        final_balances.append(results['final_balance'])
        simulation_objects.append(sim)
    
    return final_balances, simulation_objects

# Run 100 simulations
print("Running 100 simulations...")
# Set seed for reproducible results
np.random.seed(42)
random.seed(42)

final_balances_100, sim_objects_100 = run_multiple_simulations(num_simulations=100, num_flips=15)

print(f"Completed {len(final_balances_100)} simulations")
print(f"Average final balance: ${np.mean(final_balances_100):,.2f}")
print(f"Median final balance: ${np.median(final_balances_100):,.2f}")
print(f"Standard deviation: ${np.std(final_balances_100):,.2f}")
print(f"Min final balance: ${np.min(final_balances_100):,.2f}")
print(f"Max final balance: ${np.max(final_balances_100):,.2f}")
```

```{python}
#| label: probability-distribution-analysis
#| echo: false

def create_probability_distribution_plot(final_balances, initial_balance=1000.0, figsize=(15, 10)):
    """
    Create a comprehensive probability distribution analysis with multiple visualizations.
    
    Parameters:
    - final_balances: List of final balances from simulations
    - initial_balance: Starting balance for reference
    - figsize: Figure size tuple
    """
    plt.style.use('seaborn-v0_8')
    fig, axes = plt.subplots(2, 2, figsize=figsize)
    
    # Convert to numpy array for easier calculations
    balances = np.array(final_balances)
    
    # 1. Histogram with probability density
    n, bins, patches = axes[0, 0].hist(balances, bins=30, alpha=0.7, color='skyblue', 
                                      edgecolor='black', linewidth=0.5, density=True)
    axes[0, 0].axvline(initial_balance, color='red', linestyle='--', linewidth=2, 
                       alpha=0.8, label=f'Initial Balance (${initial_balance:,.0f})')
    axes[0, 0].axvline(np.mean(balances), color='green', linestyle='-', linewidth=2, 
                       alpha=0.8, label=f'Mean (${np.mean(balances):,.0f})')
    axes[0, 0].set_xlabel('Final Account Balance ($)', fontsize=12, fontweight='bold')
    axes[0, 0].set_ylabel('Probability Density', fontsize=12, fontweight='bold')
    axes[0, 0].set_title('Probability Distribution of Final Account Balances', fontsize=14, fontweight='bold')
    axes[0, 0].legend(fontsize=10)
    axes[0, 0].grid(True, alpha=0.3)
    
    # 2. Box plot with detailed statistics
    box_plot = axes[0, 1].boxplot([balances], labels=['Final Balances'], patch_artist=True)
    box_plot['boxes'][0].set_facecolor('lightblue')
    axes[0, 1].axhline(initial_balance, color='red', linestyle='--', linewidth=2, 
                       alpha=0.8, label=f'Initial Balance (${initial_balance:,.0f})')
    axes[0, 1].set_ylabel('Final Account Balance ($)', fontsize=12, fontweight='bold')
    axes[0, 1].set_title('Distribution Summary (Box Plot)', fontsize=14, fontweight='bold')
    axes[0, 1].legend(fontsize=10)
    axes[0, 1].grid(True, alpha=0.3)
    
    # 3. Cumulative distribution function
    sorted_balances = np.sort(balances)
    cumulative_prob = np.arange(1, len(sorted_balances) + 1) / len(sorted_balances)
    axes[1, 0].plot(sorted_balances, cumulative_prob, linewidth=2, color='purple')
    axes[1, 0].axvline(initial_balance, color='red', linestyle='--', linewidth=2, 
                       alpha=0.8, label=f'Initial Balance (${initial_balance:,.0f})')
    axes[1, 0].axhline(0.5, color='green', linestyle=':', alpha=0.7, label='50th Percentile')
    axes[1, 0].set_xlabel('Final Account Balance ($)', fontsize=12, fontweight='bold')
    axes[1, 0].set_ylabel('Cumulative Probability', fontsize=12, fontweight='bold')
    axes[1, 0].set_title('Cumulative Distribution Function', fontsize=14, fontweight='bold')
    axes[1, 0].legend(fontsize=10)
    axes[1, 0].grid(True, alpha=0.3)
    
    # 4. Log scale distribution (to better show the wide range)
    log_balances = np.log10(balances)
    axes[1, 1].hist(log_balances, bins=25, alpha=0.7, color='orange', 
                    edgecolor='black', linewidth=0.5, density=True)
    axes[1, 1].axvline(np.log10(initial_balance), color='red', linestyle='--', linewidth=2, 
                       alpha=0.8, label=f'Initial Balance (${initial_balance:,.0f})')
    axes[1, 1].axvline(np.log10(np.mean(balances)), color='green', linestyle='-', linewidth=2, 
                       alpha=0.8, label=f'Mean (${np.mean(balances):,.0f})')
    axes[1, 1].set_xlabel('Log10(Final Account Balance)', fontsize=12, fontweight='bold')
    axes[1, 1].set_ylabel('Probability Density', fontsize=12, fontweight='bold')
    axes[1, 1].set_title('Distribution (Log Scale)', fontsize=14, fontweight='bold')
    axes[1, 1].legend(fontsize=10)
    axes[1, 1].grid(True, alpha=0.3)
    
    plt.tight_layout()
    return fig

# Create the probability distribution plot
fig_dist = create_probability_distribution_plot(final_balances_100)
plt.show()
```

```{python}
#| label: detailed-statistics-analysis
#| echo: false

def analyze_simulation_results(final_balances, initial_balance=1000.0):
    """
    Provide detailed statistical analysis of simulation results.
    
    Parameters:
    - final_balances: List of final balances from simulations
    - initial_balance: Starting balance for reference
    
    Returns:
    - Dictionary with comprehensive statistics
    """
    balances = np.array(final_balances)
    
    # Basic statistics
    mean_balance = np.mean(balances)
    median_balance = np.median(balances)
    std_balance = np.std(balances)
    min_balance = np.min(balances)
    max_balance = np.max(balances)
    
    # Percentiles
    percentiles = [5, 10, 25, 50, 75, 90, 95]
    percentile_values = np.percentile(balances, percentiles)
    
    # Win/loss analysis
    above_initial = np.sum(balances > initial_balance)
    below_initial = np.sum(balances < initial_balance)
    equal_initial = np.sum(balances == initial_balance)
    
    # Risk metrics
    losses = balances[balances < initial_balance]
    gains = balances[balances > initial_balance]
    
    avg_loss = np.mean(losses) if len(losses) > 0 else 0
    avg_gain = np.mean(gains) if len(gains) > 0 else 0
    
    # Expected value comparison
    expected_value_per_flip = 1.05  # From our earlier calculation
    theoretical_expected = initial_balance * (expected_value_per_flip ** 15)  # 15 flips
    
    analysis = {
        'total_simulations': len(balances),
        'mean_balance': mean_balance,
        'median_balance': median_balance,
        'std_balance': std_balance,
        'min_balance': min_balance,
        'max_balance': max_balance,
        'percentiles': dict(zip(percentiles, percentile_values)),
        'above_initial': above_initial,
        'below_initial': below_initial,
        'equal_initial': equal_initial,
        'win_rate': above_initial / len(balances),
        'avg_loss': avg_loss,
        'avg_gain': avg_gain,
        'theoretical_expected': theoretical_expected,
        'actual_vs_theoretical': mean_balance / theoretical_expected
    }
    
    return analysis

# Perform detailed analysis
analysis_100 = analyze_simulation_results(final_balances_100)

print("=== DETAILED STATISTICAL ANALYSIS ===")
print(f"Total Simulations: {analysis_100['total_simulations']}")
print(f"Mean Final Balance: ${analysis_100['mean_balance']:,.2f}")
print(f"Median Final Balance: ${analysis_100['median_balance']:,.2f}")
print(f"Standard Deviation: ${analysis_100['std_balance']:,.2f}")
print(f"Min Final Balance: ${analysis_100['min_balance']:,.2f}")
print(f"Max Final Balance: ${analysis_100['max_balance']:,.2f}")
print(f"Win Rate (% above $1000): {analysis_100['win_rate']:.1%}")
print(f"Average Loss (when losing): ${analysis_100['avg_loss']:,.2f}")
print(f"Average Gain (when winning): ${analysis_100['avg_gain']:,.2f}")
print(f"Theoretical Expected Value: ${analysis_100['theoretical_expected']:,.2f}")
print(f"Actual vs Theoretical: {analysis_100['actual_vs_theoretical']:.3f}")

print("\n=== PERCENTILE ANALYSIS ===")
for pct, value in analysis_100['percentiles'].items():
    print(f"{pct}th Percentile: ${value:,.2f}")

print(f"\n=== RISK ASSESSMENT ===")
print(f"Probability of losing money: {analysis_100['below_initial']/analysis_100['total_simulations']:.1%}")
print(f"Probability of gaining money: {analysis_100['above_initial']/analysis_100['total_simulations']:.1%}")
print(f"Largest loss: ${analysis_100['min_balance'] - 1000:,.2f}")
print(f"Largest gain: ${analysis_100['max_balance'] - 1000:,.2f}")
```

```{python}
#| label: probability-and-standard-deviation-analysis
#| echo: false

def calculate_detailed_probabilities(final_balances, initial_balance=1000.0):
    """
    Calculate detailed probability metrics and standard deviation analysis.
    
    Parameters:
    - final_balances: List of final balances from simulations
    - initial_balance: Starting balance for reference
    
    Returns:
    - Dictionary with detailed probability metrics
    """
    balances = np.array(final_balances)
    
    # Basic statistics
    mean_balance = np.mean(balances)
    std_balance = np.std(balances)
    median_balance = np.median(balances)
    
    # Win/Loss probabilities
    wins = balances[balances > initial_balance]
    losses = balances[balances < initial_balance]
    ties = balances[balances == initial_balance]
    
    prob_win = len(wins) / len(balances)
    prob_loss = len(losses) / len(balances)
    prob_tie = len(ties) / len(balances)
    
    # Standard deviation analysis
    one_std_above = mean_balance + std_balance
    one_std_below = mean_balance - std_balance
    two_std_above = mean_balance + (2 * std_balance)
    two_std_below = mean_balance - (2 * std_balance)
    
    # Count simulations within standard deviations
    within_one_std = np.sum((balances >= one_std_below) & (balances <= one_std_above))
    within_two_std = np.sum((balances >= two_std_below) & (balances <= two_std_above))
    
    prob_within_one_std = within_one_std / len(balances)
    prob_within_two_std = within_two_std / len(balances)
    
    # Calculate how far one std is from mean in percentage terms
    std_as_pct_of_mean = (std_balance / mean_balance) * 100
    
    # Risk metrics
    if len(losses) > 0:
        avg_loss_pct = np.mean((losses - initial_balance) / initial_balance) * 100
        max_loss_pct = np.min((losses - initial_balance) / initial_balance) * 100
    else:
        avg_loss_pct = 0
        max_loss_pct = 0
    
    if len(wins) > 0:
        avg_gain_pct = np.mean((wins - initial_balance) / initial_balance) * 100
        max_gain_pct = np.max((wins - initial_balance) / initial_balance) * 100
    else:
        avg_gain_pct = 0
        max_gain_pct = 0
    
    return {
        'mean_balance': mean_balance,
        'std_balance': std_balance,
        'median_balance': median_balance,
        'prob_win': prob_win,
        'prob_loss': prob_loss,
        'prob_tie': prob_tie,
        'one_std_above': one_std_above,
        'one_std_below': one_std_below,
        'two_std_above': two_std_above,
        'two_std_below': two_std_below,
        'prob_within_one_std': prob_within_one_std,
        'prob_within_two_std': prob_within_two_std,
        'std_as_pct_of_mean': std_as_pct_of_mean,
        'avg_loss_pct': avg_loss_pct,
        'max_loss_pct': max_loss_pct,
        'avg_gain_pct': avg_gain_pct,
        'max_gain_pct': max_gain_pct,
        'total_simulations': len(balances)
    }

# Calculate detailed probabilities
prob_analysis = calculate_detailed_probabilities(final_balances_100)

print("=== PROBABILITY ANALYSIS ===")
print(f"Probability of WINNING money: {prob_analysis['prob_win']:.1%}")
print(f"Probability of LOSING money: {prob_analysis['prob_loss']:.1%}")
print(f"Probability of BREAKING EVEN: {prob_analysis['prob_tie']:.1%}")

print(f"\n=== STANDARD DEVIATION ANALYSIS ===")
print(f"Mean Final Balance: ${prob_analysis['mean_balance']:,.2f}")
print(f"Standard Deviation: ${prob_analysis['std_balance']:,.2f}")
print(f"Standard Deviation as % of Mean: {prob_analysis['std_as_pct_of_mean']:.1f}%")
print(f"")
print(f"One Standard Deviation Above Mean: ${prob_analysis['one_std_above']:,.2f}")
print(f"One Standard Deviation Below Mean: ${prob_analysis['one_std_below']:,.2f}")
print(f"")
print(f"Two Standard Deviations Above Mean: ${prob_analysis['two_std_above']:,.2f}")
print(f"Two Standard Deviations Below Mean: ${prob_analysis['two_std_below']:,.2f}")

print(f"\n=== DISTRIBUTION WITHIN STANDARD DEVIATIONS ===")
print(f"Simulations within 1 standard deviation: {prob_analysis['prob_within_one_std']:.1%}")
print(f"Simulations within 2 standard deviations: {prob_analysis['prob_within_two_std']:.1%}")

print(f"\n=== GAIN/LOSS PERCENTAGE ANALYSIS ===")
print(f"Average Loss (when losing): {prob_analysis['avg_loss_pct']:.1f}%")
print(f"Maximum Loss: {prob_analysis['max_loss_pct']:.1f}%")
print(f"Average Gain (when winning): {prob_analysis['avg_gain_pct']:.1f}%")
print(f"Maximum Gain: {prob_analysis['max_gain_pct']:.1f}%")

# Create visualization of standard deviation ranges
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))

# Plot 1: Histogram with standard deviation bands
ax1.hist(final_balances_100, bins=30, alpha=0.7, color='skyblue', edgecolor='black', density=True)
ax1.axvline(prob_analysis['mean_balance'], color='red', linestyle='-', linewidth=2, label=f'Mean (${prob_analysis["mean_balance"]:,.0f})')
ax1.axvline(prob_analysis['one_std_above'], color='orange', linestyle='--', linewidth=2, label=f'+1 Std (${prob_analysis["one_std_above"]:,.0f})')
ax1.axvline(prob_analysis['one_std_below'], color='orange', linestyle='--', linewidth=2, label=f'-1 Std (${prob_analysis["one_std_below"]:,.0f})')
ax1.axvline(1000, color='green', linestyle=':', linewidth=2, label='Initial Balance ($1,000)')
ax1.set_xlabel('Final Account Balance ($)')
ax1.set_ylabel('Probability Density')
ax1.set_title('Distribution with Standard Deviation Bands')
ax1.legend()
ax1.grid(True, alpha=0.3)

# Plot 2: Win/Loss probability pie chart
labels = ['Wins', 'Losses', 'Ties']
sizes = [prob_analysis['prob_win'], prob_analysis['prob_loss'], prob_analysis['prob_tie']]
colors = ['lightgreen', 'lightcoral', 'lightblue']
explode = (0.1, 0, 0)  # Explode the largest slice

ax2.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%', startangle=90)
ax2.set_title('Win/Loss Probability Distribution')

plt.tight_layout()
plt.show()

print(f"\n=== KEY INSIGHTS ===")
print(f"â€¢ The standard deviation is {prob_analysis['std_as_pct_of_mean']:.1f}% of the mean, indicating extremely high volatility")
print(f"â€¢ Only {prob_analysis['prob_within_one_std']:.1f}% of simulations fall within one standard deviation of the mean")
print(f"â€¢ The probability of losing money ({prob_analysis['prob_loss']:.1f}%) is much higher than winning ({prob_analysis['prob_win']:.1f}%)")
print(f"â€¢ When you lose, you lose an average of {abs(prob_analysis['avg_loss_pct']):.1f}% of your initial investment")
print(f"â€¢ When you win, you gain an average of {prob_analysis['avg_gain_pct']:.1f}% of your initial investment")
```

This time, after the 100 simulations, we were able to gain a lot of statistical insight about the distribution of outcomes. The results reveal a fascinating paradox: despite having a positive expected value of 5% per flip, most individual simulations actually result in losses. This occurs because the high volatility creates extreme outliers that pull the average up, while the majority of simulations cluster around much lower values. The distribution is heavily right-skewed, showing that this strategy behaves more like a lottery ticket - most people lose, but a few achieve enormous gains. This counterintuitive result perfectly demonstrates why expected value alone is insufficient for evaluating investment strategies, and why understanding the full distribution of possible outcomes is crucial for making informed financial decisions.


Based on our 100 simulations, the probability of ending with an account balance over $1,000 at age 55 is approximately 33%. This low success rate occurs because the strategy's high volatility creates a compounding effect where early losses severely reduce the base for future gains. The 40% loss multiplier has a more devastating impact than the 50% gain multiplier, as losing 40% requires a 67% gain just to break even. Additionally, the random nature of coin flips means that unfavorable sequences of losses early in the investment period can quickly deplete the account balance beyond recovery. The strategy's positive expected value is primarily driven by a small number of extremely lucky simulations that achieve multiple consecutive wins, while the majority of investors experience the harsh reality of compounding losses.

## Modified Game Strategy Analysis

Now let's explore a modified version of the game with different betting rules to answer the specific questions about the probability of ending with over $10,000 at age 55.

### Modified Game Rules:
- **Starting balance**: $1,000
- **Bet amount**: Always 50% of current account balance
- **Win condition**: +50% gain on the bet amount (+25% of total balance)
- **Loss condition**: -40% loss on the bet amount (-20% of total balance)
- **Frequency**: Once per year until age 55 (15 flips total)

```{python}
#| label: modified-game-strategy
#| echo: false

class ModifiedInvestmentSimulation:
    """
    Modified investment simulation with 50% betting rule.
    """
    
    def __init__(self, initial_balance=1000.0, win_probability=0.5, 
                 win_multiplier=0.5, loss_multiplier=0.4):
        self.initial_balance = initial_balance
        self.win_probability = win_probability
        self.win_multiplier = win_multiplier  # 50% gain on bet
        self.loss_multiplier = loss_multiplier  # 40% loss on bet
        self.balance_history = []
        self.bet_history = []
        self.flip_results = []
        self.flip_numbers = []
        
    def run_single_simulation(self, num_flips=15):
        """
        Run a single simulation with the modified betting rules.
        """
        # Reset history
        self.balance_history = [self.initial_balance]
        self.bet_history = []
        self.flip_results = []
        self.flip_numbers = []
        
        current_balance = self.initial_balance
        
        for flip in range(1, num_flips + 1):
            # Calculate bet amount (50% of current balance)
            bet_amount = current_balance * 0.5
            
            # Simulate coin flip
            coin_flip = random.random() < self.win_probability
            
            if coin_flip:  # Win: +50% gain on bet amount
                gain = bet_amount * self.win_multiplier
                current_balance += gain
                result = "WIN"
            else:  # Lose: -40% loss on bet amount
                loss = bet_amount * self.loss_multiplier
                current_balance -= loss
                result = "LOSS"
            
            # Record results
            self.balance_history.append(current_balance)
            self.bet_history.append(bet_amount)
            self.flip_results.append(result)
            self.flip_numbers.append(flip)
        
        return {
            'final_balance': current_balance,
            'total_gain_loss': current_balance - self.initial_balance,
            'total_gain_loss_pct': ((current_balance - self.initial_balance) / self.initial_balance) * 100,
            'wins': self.flip_results.count("WIN"),
            'losses': self.flip_results.count("LOSS"),
            'win_rate': self.flip_results.count("WIN") / len(self.flip_results)
        }

# Run 100 modified simulations
print("Running 100 modified strategy simulations...")
modified_balances_100 = []

# Set seed for reproducible results
np.random.seed(42)
random.seed(42)

for i in range(100):
    # Set individual seed for each simulation to ensure reproducibility
    np.random.seed(42 + i)
    random.seed(42 + i)
    
    sim = ModifiedInvestmentSimulation()
    results = sim.run_single_simulation(num_flips=15)
    modified_balances_100.append(results['final_balance'])

print(f"Completed {len(modified_balances_100)} modified simulations")
print(f"Average final balance: ${np.mean(modified_balances_100):,.2f}")
print(f"Median final balance: ${np.median(modified_balances_100):,.2f}")
print(f"Standard deviation: ${np.std(modified_balances_100):,.2f}")
print(f"Min final balance: ${np.min(modified_balances_100):,.2f}")
print(f"Max final balance: ${np.max(modified_balances_100):,.2f}")
```

```{python}
#| label: modified-strategy-analysis
#| echo: false

# Calculate probabilities for modified strategy
modified_balances_array = np.array(modified_balances_100)

# Probability of ending above $1,000
prob_above_1000_modified = np.mean(modified_balances_array > 1000)

# Probability of ending above $10,000
prob_above_10000_modified = np.mean(modified_balances_array > 10000)

# Compare with original strategy
prob_above_1000_original = np.mean(np.array(final_balances_100) > 1000)
prob_above_10000_original = np.mean(np.array(final_balances_100) > 10000)

print("=== MODIFIED STRATEGY PROBABILITY ANALYSIS ===")
print(f"Probability of ending above $1,000: {prob_above_1000_modified:.1%}")
print(f"Probability of ending above $10,000: {prob_above_10000_modified:.1%}")

print(f"\n=== COMPARISON WITH ORIGINAL STRATEGY ===")
print(f"Original Strategy - Above $1,000: {prob_above_1000_original:.1%}")
print(f"Modified Strategy - Above $1,000: {prob_above_1000_modified:.1%}")
print(f"")
print(f"Original Strategy - Above $10,000: {prob_above_10000_original:.1%}")
print(f"Modified Strategy - Above $10,000: {prob_above_10000_modified:.1%}")

# Calculate which is higher
if prob_above_10000_modified > prob_above_10000_original:
    comparison = "HIGHER"
    difference = prob_above_10000_modified - prob_above_10000_original
else:
    comparison = "LOWER"
    difference = prob_above_10000_original - prob_above_10000_modified

print(f"\n=== ANSWER TO SPECIFIC QUESTIONS ===")
print(f"1. Probability of ending above $10,000 with modified strategy: {prob_above_10000_modified:.1%}")
print(f"2. This probability is {comparison} than the original strategy by {difference:.1%}")

# Create comparison visualization
fig, axes = plt.subplots(1, 2, figsize=(15, 6))

# Original strategy histogram
axes[0].hist(final_balances_100, bins=30, alpha=0.7, color='skyblue', 
             edgecolor='black', density=True, label='Original Strategy')
axes[0].axvline(1000, color='red', linestyle='--', alpha=0.7, label='$1,000')
axes[0].axvline(10000, color='green', linestyle='--', alpha=0.7, label='$10,000')
axes[0].set_xlabel('Final Account Balance ($)')
axes[0].set_ylabel('Probability Density')
axes[0].set_title('Original Strategy Distribution')
axes[0].legend()
axes[0].grid(True, alpha=0.3)

# Modified strategy histogram
axes[1].hist(modified_balances_100, bins=30, alpha=0.7, color='lightcoral', 
             edgecolor='black', density=True, label='Modified Strategy')
axes[1].axvline(1000, color='red', linestyle='--', alpha=0.7, label='$1,000')
axes[1].axvline(10000, color='green', linestyle='--', alpha=0.7, label='$10,000')
axes[1].set_xlabel('Final Account Balance ($)')
axes[1].set_ylabel('Probability Density')
axes[1].set_title('Modified Strategy Distribution')
axes[1].legend()
axes[1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# Additional analysis
print(f"\n=== DETAILED COMPARISON ===")
print(f"Modified strategy mean: ${np.mean(modified_balances_100):,.2f}")
print(f"Original strategy mean: ${np.mean(final_balances_100):,.2f}")
print(f"Modified strategy std: ${np.std(modified_balances_100):,.2f}")
print(f"Original strategy std: ${np.std(final_balances_100):,.2f}")

# Count simulations above $10,000
count_above_10k_modified = np.sum(modified_balances_array > 10000)
count_above_10k_original = np.sum(np.array(final_balances_100) > 10000)

print(f"\nSimulations ending above $10,000:")
print(f"Modified strategy: {count_above_10k_modified}/100")
print(f"Original strategy: {count_above_10k_original}/100")
```

### Analysis Results

Based on our 100 simulations of the modified game strategy, we can answer the specific questions:

**Question 1: What is the probability that your account balance will be greater than $10,000 at age 55?**

The probability of ending with an account balance greater than $10,000 at age 55 using the modified strategy is approximately 0%, compared to about 6% for the original strategy.

**Question 2: Is this probability higher or lower than the probability in the original game?**

This probability is 52% vs 27% with the original strategy for winning money. The modified strategy's 50% betting rule creates different risk-return characteristics compared to the original strategy's all-or-nothing approach on each flip.

The modified strategy's requirement to bet exactly 50% of the current balance on each flip creates more moderate compounding effects, which can lead to different outcomes in terms of both the probability of achieving high balances and the overall distribution of final results.


