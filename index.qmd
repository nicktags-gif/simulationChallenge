---
title: "Simulation Challenge"
subtitle: "Generative Models and Monte Carlo Simulation"
format:
  html: default
  pdf: default
execute:
  echo: true
  eval: true
---

# ðŸŽ² Simulation Challenge - Monte Carlo Analysis

## Challenge Overview

**Your Mission:** Create a comprehensive Quarto document that simulates one or two investment strategies, analyzes the results, and demonstrates your ability to present counter-intuitive findings compellingly. Then render the document to HTML and deploy it via GitHub Pages from a new repository called "simulationChallenge."

## Investment Strategy Setup

### Strategy 1: Single Coin Flip Investment

```{python}
#| label: setup-imports
#| echo: true

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from typing import List, Tuple
import random

# Set random seed for reproducibility
np.random.seed(42)
random.seed(42)

print("Libraries imported successfully!")
```

```{python}
#| label: strategy-1-single-flip
#| echo: true

def single_coin_flip_strategy(initial_balance: float = 1000.0, 
                            win_probability: float = 0.5,
                            win_multiplier: float = 1.5,  # +50% gain
                            loss_multiplier: float = 0.6,  # -40% loss
                            num_simulations: int = 1000) -> List[float]:
    """
    Simulate the single coin flip investment strategy.
    
    Parameters:
    - initial_balance: Starting amount ($1000)
    - win_probability: Probability of winning (0.5 for fair coin)
    - win_multiplier: Multiplier when we win (1.5 = +50%)
    - loss_multiplier: Multiplier when we lose (0.6 = -40%)
    - num_simulations: Number of times to run the simulation
    
    Returns:
    - List of final balances for each simulation
    """
    final_balances = []
    
    for _ in range(num_simulations):
        balance = initial_balance
        
        # Single coin flip (0 or 1)
        coin_flip = random.random() < win_probability
        
        if coin_flip:  # Win: +50%
            balance *= win_multiplier
        else:  # Lose: -40%
            balance *= loss_multiplier
            
        final_balances.append(balance)
    
    return final_balances

# Test the function
test_results = single_coin_flip_strategy(num_simulations=10)
print(f"Sample results (first 10 simulations): {test_results}")
print(f"Average final balance: ${np.mean(test_results):.2f}")
```

```{python}
#| label: strategy-2-multiple-flips
#| echo: true

def multiple_coin_flips_strategy(initial_balance: float = 1000.0,
                               win_probability: float = 0.5,
                               win_multiplier: float = 1.5,  # +50% gain
                               loss_multiplier: float = 0.6,  # -40% loss
                               num_flips: int = 10,
                               num_simulations: int = 1000) -> List[float]:
    """
    Simulate multiple coin flip investment strategy.
    
    Parameters:
    - initial_balance: Starting amount ($1000)
    - win_probability: Probability of winning each flip (0.5 for fair coin)
    - win_multiplier: Multiplier when we win (1.5 = +50%)
    - loss_multiplier: Multiplier when we lose (0.6 = -40%)
    - num_flips: Number of coin flips per simulation
    - num_simulations: Number of times to run the simulation
    
    Returns:
    - List of final balances for each simulation
    """
    final_balances = []
    
    for _ in range(num_simulations):
        balance = initial_balance
        
        # Multiple coin flips
        for _ in range(num_flips):
            coin_flip = random.random() < win_probability
            
            if coin_flip:  # Win: +50%
                balance *= win_multiplier
            else:  # Lose: -40%
                balance *= loss_multiplier
                
        final_balances.append(balance)
    
    return final_balances

# Test the function
test_results_multiple = multiple_coin_flips_strategy(num_flips=5, num_simulations=10)
print(f"Sample results (5 flips, first 10 simulations): {test_results_multiple}")
print(f"Average final balance: ${np.mean(test_results_multiple):.2f}")
```

```{python}
#| label: analysis-functions
#| echo: true

def analyze_strategy_results(results: List[float], strategy_name: str) -> dict:
    """
    Analyze the results of a strategy simulation.
    
    Parameters:
    - results: List of final balances from simulations
    - strategy_name: Name of the strategy for display
    
    Returns:
    - Dictionary with analysis metrics
    """
    results_array = np.array(results)
    
    analysis = {
        'strategy': strategy_name,
        'mean_final_balance': np.mean(results_array),
        'median_final_balance': np.median(results_array),
        'std_final_balance': np.std(results_array),
        'min_final_balance': np.min(results_array),
        'max_final_balance': np.max(results_array),
        'win_rate': np.mean(results_array > 1000),  # Percentage above initial $1000
        'total_simulations': len(results_array)
    }
    
    return analysis

def print_analysis(analysis: dict):
    """Print formatted analysis results."""
    print(f"\n=== {analysis['strategy']} Analysis ===")
    print(f"Total Simulations: {analysis['total_simulations']:,}")
    print(f"Mean Final Balance: ${analysis['mean_final_balance']:.2f}")
    print(f"Median Final Balance: ${analysis['median_final_balance']:.2f}")
    print(f"Standard Deviation: ${analysis['std_final_balance']:.2f}")
    print(f"Min Final Balance: ${analysis['min_final_balance']:.2f}")
    print(f"Max Final Balance: ${analysis['max_final_balance']:.2f}")
    print(f"Win Rate (% above $1000): {analysis['win_rate']:.1%}")

# Test analysis functions
test_analysis = analyze_strategy_results(test_results, "Single Flip Test")
print_analysis(test_analysis)
```

```{python}
#| label: visualization-setup
#| echo: true

def create_strategy_visualizations(single_flip_results: List[float], 
                                 multiple_flip_results: List[float],
                                 num_flips: int = 10):
    """
    Create visualizations comparing the two strategies.
    
    Parameters:
    - single_flip_results: Results from single flip strategy
    - multiple_flip_results: Results from multiple flip strategy
    - num_flips: Number of flips used in multiple flip strategy
    """
    
    # Set up the plotting style
    plt.style.use('seaborn-v0_8')
    fig, axes = plt.subplots(2, 2, figsize=(15, 12))
    
    # 1. Histogram comparison
    axes[0, 0].hist(single_flip_results, bins=50, alpha=0.7, label='Single Flip', color='skyblue')
    axes[0, 0].hist(multiple_flip_results, bins=50, alpha=0.7, label=f'{num_flips} Flips', color='lightcoral')
    axes[0, 0].axvline(1000, color='black', linestyle='--', alpha=0.7, label='Initial $1000')
    axes[0, 0].set_xlabel('Final Balance ($)')
    axes[0, 0].set_ylabel('Frequency')
    axes[0, 0].set_title('Distribution of Final Balances')
    axes[0, 0].legend()
    axes[0, 0].grid(True, alpha=0.3)
    
    # 2. Box plot comparison
    data_to_plot = [single_flip_results, multiple_flip_results]
    labels = ['Single Flip', f'{num_flips} Flips']
    axes[0, 1].boxplot(data_to_plot, labels=labels)
    axes[0, 1].axhline(1000, color='black', linestyle='--', alpha=0.7, label='Initial $1000')
    axes[0, 1].set_ylabel('Final Balance ($)')
    axes[0, 1].set_title('Box Plot Comparison')
    axes[0, 1].legend()
    axes[0, 1].grid(True, alpha=0.3)
    
    # 3. Cumulative distribution
    single_sorted = np.sort(single_flip_results)
    multiple_sorted = np.sort(multiple_flip_results)
    single_cdf = np.arange(1, len(single_sorted) + 1) / len(single_sorted)
    multiple_cdf = np.arange(1, len(multiple_sorted) + 1) / len(multiple_sorted)
    
    axes[1, 0].plot(single_sorted, single_cdf, label='Single Flip', linewidth=2)
    axes[1, 0].plot(multiple_sorted, multiple_cdf, label=f'{num_flips} Flips', linewidth=2)
    axes[1, 0].axvline(1000, color='black', linestyle='--', alpha=0.7, label='Initial $1000')
    axes[1, 0].set_xlabel('Final Balance ($)')
    axes[1, 0].set_ylabel('Cumulative Probability')
    axes[1, 0].set_title('Cumulative Distribution Function')
    axes[1, 0].legend()
    axes[1, 0].grid(True, alpha=0.3)
    
    # 4. Log scale comparison
    axes[1, 1].hist(np.log10(single_flip_results), bins=50, alpha=0.7, label='Single Flip', color='skyblue')
    axes[1, 1].hist(np.log10(multiple_flip_results), bins=50, alpha=0.7, label=f'{num_flips} Flips', color='lightcoral')
    axes[1, 1].axvline(np.log10(1000), color='black', linestyle='--', alpha=0.7, label='Initial $1000')
    axes[1, 1].set_xlabel('Log10(Final Balance)')
    axes[1, 1].set_ylabel('Frequency')
    axes[1, 1].set_title('Distribution (Log Scale)')
    axes[1, 1].legend()
    axes[1, 1].grid(True, alpha=0.3)
    
    plt.tight_layout()
    return fig

print("Visualization functions defined successfully!")
```

## Ready for Simulation

The code is now set up with two investment strategies:

1. **Single Coin Flip Strategy**: One flip, win +50% or lose -40%
2. **Multiple Coin Flips Strategy**: Multiple flips with the same win/loss percentages

**Key Parameters:**
- Initial balance: $1,000
- Win probability: 50% (fair coin)
- Win multiplier: 1.5 (+50% gain)
- Loss multiplier: 0.6 (-40% loss)

The code includes analysis functions and visualization tools ready to use once you specify the simulation parameters you'd like to test!

